```
TIP: 102
Title: Hierarchical Deterministic Wallet
Author: federico<federico.zhen@tron.network>
discussions-to: https://github.com/tronprotocol/tips/issues/102
status: Last Call
type: Standards Track
category: TRC
Created: 2019-10-22
```

## Simple Summary

This proposal defines a mechanism for extending hierarchical deterministic wallets, as described in [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
and [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki), to support both Tron's transparent and shielded addresses.

## Abstract

[BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) and [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) are the standard mechanism by which wallets for Bitcoin and its derivatives  generate keys and addresses deterministically. 
However, they only support the transparent address generation. This specification will provide support for the hierarchically shielded addresses derivation in a similar way as [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), which can offer users better privacy protection. 


## Motivation
 At present, Tron network has scheduled to support the shielded addresses by ZK-SNARKs, so it is necessary to provide the standard compatibility for shielded hierarchical deterministic wallets.  

## Specification

In this specification, transparent address indicates the address which is public in the transaction, while the shielded address stands for the address which
is not available from the transaction.

### Wallet Key Path

Existing HD wallets all use [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) to organize their derived keys. In order to
improve existing user experiences, we broadly follow BIP 44's design here. However, we have
altered the design where it makes sense to leverage features of shielded addresses.

    m / purpose' / coin_type' / account' / transparent' / change / address_index
        
Apostrophe in the path indicates that BIP32 hardened derivation is used.
 
- ``m``: a seed generated by the mnemonic codes to generate the master key.
     
- ``purpose``: a constant set to 102' (or 0x80000066)  following the [BIP43](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki) recommendation. It indicates that
  the subtree of this node is used according to this specification.

- ``coin_type``: a constant identifying the cybercoin that this subtree's keys are used with. For Tron, ``coin_type`` is 195 as assigned in [SLIP44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md). 

- ``account``: numbered from index 0 in sequentially increasing manner. Defined as in [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki).

- ``transparent``: for transparent addresses, ``transparent`` is set 1; for the shielded addresses, ``transparent`` is set 0;

- ``change``: for transparent addresses, constant 0 is used for external chain and constant 1 for internal chain (also known as change addresses) as in [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki); 
   for shielded addresses, ``change`` field is omitted, because shielded addresses are never publicly visible in transactions.

- ``address_index``: numbered from index 0 in sequentially increasing manner. Defined as in [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki).

### Mnemonic Codes

[BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) should be used to derive binary seed from a mnemonic code.

We strongly recommend using 24 word mnemonic (256 bits of entropy).

### Transparent Multi-Account Hierarchy for Deterministic Wallets

We adapt [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) for generating transparent address, except an extra ``transparent`` field is added. This is an upgrade of [TIP001](https://github.com/tronprotocol/tips/blob/master/tip-01.md). We will focus on the shielded addresses derivation in the following section.  


## Hierarchical Derivation for Shielded Addresses
The shielded addresses derivation process described here are mainly based on the [ZIP32](https://github.com/zcash/zips/blob/master/zip-0032.rst) standard proposed by Zcash team.

### Conventions

Most of the notation and functions used in this TIP are defined here for convenience:

- truncate<sub>k</sub>(*S*) means the sequence formed from the first *k* elements of *S*.

- *a* || *b* means the concatenation of sequences *a* then *b*.

- [*k*] *P* means scalar multiplication of the elliptic curve point *P* by the scalar *k*.

- LEOS2IP<sub>l</sub> (*S*) is the integer in range {0..2<sup>l</sup> -1} represented in little-endian order
  by the byte sequence *S* of length *l*/8.

- I2LEBSP<sub>l</sub> (*k*) is the sequence of *l* bits representing *k* in little-endian order.

- LEBS2OSP<sub>l</sub> (*B*) is defined as follows when *l* is a multiple of 8: convert each group of 8 bits
  in *B* to a byte value with the least significant bit first, and concatenate the resulting bytes in the
  same order as the groups.

- repr<sub>J</sub> (*P*) is the representation of the Jubjub elliptic curve point *P* as a bit sequence.

- BLAKE2b-256(*p*, *x*) refers to unkeyed BLAKE2b-256 in sequential mode, with an output digest length of
  32 bytes, 16-byte personalization string *p*, and input *x*.

- BLAKE2b-512(*p*, *x*) refers to unkeyed BLAKE2b-512 in sequential mode, with an output digest length of
  64 bytes, 16-byte personalization string *p*, and input *x*.

- PRF<sup>expand</sup> (*sk*, *t*) := BLAKE2b-512("Tron_ExpandSeed", *sk* || *t* )

- ToScalar(*x*) := LEOS2IP<sub>512</sub> (*x*) (mod *r*<sub>J</sub> ), where *r*<sub>J</sub> is the order
  of the Jubjub large prime subgroup.

- DiversifyHash(*d*) maps a diversifier *d* to a base point on the Jubjub elliptic curve, or to ⊥ if the
  diversifier is invalid. 

The following [FPE](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38G.pdf) algorithm standardized is used:

- FF1-AES256.Encrypt(*key*, *tweak*, *x*) refers to the FF1 encryption algorithm using AES with a
  256-bit *key*, and parameters *radix* = 2, *minlen* = 88, *maxlen* = 88. It will be used only with
  the empty string "" as the *tweak*. *x* is a sequence of 88 bits, as is the output.

We also define the following conversion function:

- I2LEOSP<sub>l</sub> (*k*) is the byte sequence *S* of length *l*/8 representing in little-endian order the
  integer *k* in range {0..2<sup>l</sup> -1}. It is the reverse operation of LEOS2IP<sub>l</sub> (*S*).


We adapt the path notation of [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) to describe shielded HD paths, using apostrophes to
indicate hardened derivation (i' = i + 2<sup>31</sup> ) as in [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki):

- CDKsk(CDKsk(CDKsk(m, a'), b), c) is written as m / a' / b / c
- CDKfvk(CDKfvk(CDKfvk(M, a), b), c) is written as M / a / b / c


### Specification: Key Derivation

#### Extended Keys


BIP 32 defines a method to derive a number of child keys from a parent key. In order to prevent these from
depending solely on the parent key itself, both the private and public keys are extended with a 32-byte chain
code. We similarly extend Sapling keys with a chain code here. However, the concepts of "private" and "public"
keys in BIP 32 do not map cleanly to shielded key components. We take the following approach:

- We derive child expanded spending keys, rather than spending keys. This enables us to
  implement both hardened and non-hardened derivation modes.

- We do not derive public keys directly, as this would prevent the use of diversified addresses.
  Instead, we derive full viewing keys, from which payment addresses can be generated. This maintains
  the trust semantics of BIP 32: someone with access to a BIP 32 extended public key is able to view all
  transactions involving that address, which a full viewing key also enables.

We represent a extended spending key as (*ask*, *nsk*, *ovk*, *dk*, *c*), where (*ask*, *nsk*, *ovk*)
is the normal expanded spending key, *dk* is a diversifier key, and *c* is the chain code.

We represent a extended full viewing key as (*ak*, *nk*, *ovk*, *dk*, *c*), where (*ak*, *nk*, *ovk*)
is the normal full viewing key, *dk* is the same diversifier key as above, and *c* is the chain code.

#### The helper functions

Define EncodeExtSKParts(*ask*, *nsk*, *ovk*, *dk*) := I2LEOSP<sub>256</sub> (*ask*) || I2LEOSP<sub>256</sub> (*nsk*) || *ovk* || *dk*.

Define EncodeExtFVKParts(*ak*, *nk*, *ovk*, *dk*) := LEBS2OSP<sub>256</sub> (repr<sub>J</sub> (*ak*)) || LEBS2OSP<sub>256</sub> (repr<sub>J</sub> (*nk*)) || *ovk* || *dk*.

#### Master Key Generation

Let path<sub>i</sub>= m / xx' / 195' / i' / 0', *i* denotes the *i*-th account.  Let sk<sub>path<sub>i</sub></sub>, pk<sub>path<sub>i</sub></sub>, c<sub>path<sub>i</sub></sub>
denotes the private key, public key and chain code at path<sub>i</sub> derived by [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki).

- Calculate *I* = BLAKE2b-512 ("TronIP102", *sk<sub>path<sub>i</sub></sub>* || *pk<sub>path<sub>i</sub></sub>* || *c<sub>path<sub>i</sub></sub>* ).
- Split *I* into two 32-byte sequences, *I*<sub>L</sub> and *I*<sub>R</sub> .
- Use *I*<sub>L</sub> as the master spending key *sk*<sub>m</sub> , and *I*<sub>R</sub> as the master chain code
  *c*<sub>m</sub>.
- Calculate *ask*<sub>m</sub> , *nsk*<sub>m</sub> , and *ovk*<sub>m</sub> via the standard derivation function:

  - *ask*<sub>m</sub> = ToScalar(PRF<sup>expand</sup> (*sk*<sub>m</sub> , [0x00]))
  - *nsk*<sub>m</sub> = ToScalar(PRF<sup>expand</sup> (*sk*<sub>m</sub> , [0x01]))
  - *ovk*<sub>m</sub> = truncate<sub>32</sub> (PRF<sup>expand</sup> (*sk*<sub>m</sub> , [0x02]))

- Calculate *dk*<sub>m</sub> similarly:

  - *dk*<sub>m</sub> = truncate<sub>32</sub> (PRF<sup>expand</sup> (*sk*<sub>m</sub> , [0x10]))

- Return (*ask*<sub>m</sub> , *nsk*<sub>m</sub> , *ovk*<sub>m</sub> , *dk*<sub>m</sub> , *c*<sub>m</sub> ) as the
  master extended spending key *m*.

### Child Key Derivation

As in BIP 32, the method for deriving a child extended key, given a parent extended key and an index *i*,
depends on the type of key being derived, and whether this is a hardened or non-hardened derivation.

#### Deriving a child extended spending key

CDKsk((*ask*<sub>par</sub> , *nsk*<sub>par</sub> , *ovk*<sub>par</sub> , *dk*<sub>par</sub> , *c*<sub>par</sub> ), *i*) →
(*ask*<sub>i</sub> , *nsk*<sub>i</sub> , *ovk*<sub>i</sub> , *dk*<sub>i</sub> , *c*<sub>i</sub> )

- Check whether *i* ≥ 2<sup>31</sup> (whether the child is a hardened key).

  - If so (hardened child): let *I* = PRF<sup>expand</sup> (*c*<sub>par</sub> , [0x11] || EncodeExtSKParts(*ask*<sub>par</sub> , *nsk*<sub>par</sub> , *ovk*<sub>par</sub> , *dk*<sub>par</sub> ) || I2LEOSP<sub>32</sub> (*i*))
  - If not (normal child):  let *I* = PRF<sup>expand</sup> (*c*<sub>par</sub> , [0x12] || EncodeExtFVKParts(*ak*<sub>par</sub> , *nk*<sub>par</sub> , *ovk*<sub>par</sub> , *dk*<sub>par</sub> ) || I2LEOSP<sub>32</sub> (*i*))
    where (*nk*<sub>par</sub> , *ak*<sub>par</sub> , *ovk*<sub>par</sub> ) is the full viewing key derived from
    (*ask*<sub>par</sub> , *nsk*<sub>par</sub> , *ovk*<sub>par</sub> ).

- Split *I* into two 32-byte sequences, *I*<sub>L</sub> and *I*<sub>R</sub> .
- Let *I*<sub>ask</sub> = ToScalar(PRF<sup>expand</sup> (*I*<sub>L</sub> , [0x13]))
- Let *I*<sub>nsk</sub> = ToScalar(PRF<sup>expand</sup> (*I*<sub>L</sub> , [0x14]))
- Return:

  - *ask*<sub>i</sub> = *I*<sub>ask</sub> + *ask*<sub>par</sub>
  - *nsk*<sub>i</sub> = *I*<sub>nsk</sub> + *nsk*<sub>par</sub>
  - *ovk*<sub>i</sub> = truncate<sub>32</sub> (PRF<sup>expand</sup> (*I*<sub>L</sub> , [0x15] || *ovk*<sub>par</sub> ))
  - *dk*<sub>i</sub> = truncate<sub>32</sub> (PRF<sup>expand</sup> (*I*<sub>L</sub> , [0x16] || *dk*<sub>par</sub> ))
  - *c*<sub>i</sub> = *I*<sub>R</sub>

#### Deriving a child extended full viewing key

Let *G* and *H* be the base point in elliptic curve.

CDKfvk((*ak*<sub>par</sub> , *nk*<sub>par</sub> , *ovk*<sub>par</sub> , *dk*<sub>par</sub> , *c*<sub>par</sub> ), *i*) →
(*ak*<sub>i</sub> , *nk*<sub>i</sub> , *ovk*<sub>i</sub> , *dk*<sub>i</sub> , *c*<sub>i</sub> )

- Check whether *i* ≥ 2<sup>31</sup> (whether the child is a hardened key).

  - If so (hardened child): return failure
  - If not (normal child):  let *I* = PRF<sup>expand</sup> (*c*<sub>par</sub> , [0x12] || EncodeExtFVKParts(*ak*<sub>par</sub> , *nk*<sub>par</sub> , *ovk*<sub>par</sub> , *dk*<sub>par</sub> ) || I2LEOSP<sub>32</sub> (*i*))

- Split *I* into two 32-byte sequences, *I*<sub>L</sub> and *I*<sub>R</sub> .
- Let *I*<sub>ask</sub> = ToScalar(PRF<sup>expand</sup> (*I*<sub>L</sub> , [0x13]))
- Let *I*<sub>nsk</sub> = ToScalar(PRF<sup>expand</sup> (*I*<sub>L</sub> , [0x14]))
- Return:

  - *ak*<sub>i</sub> = [*I*<sub>ask</sub>] G + *ak*<sub>par</sub>
  - *nk*<sub>i</sub> = [*I*<sub>nsk</sub>] H + *nk*<sub>par</sub>
  - *ovk*<sub>i</sub> = truncate<sub>32</sub> (PRF<sup>expand</sup> (*I*<sub>L</sub> , [0x15] || *ovk*<sub>par</sub> ))
  - *dk*<sub>i</sub> = truncate<sub>32</sub> (PRF<sup>expand</sup> (*I*<sub>L</sub> , [0x16] || *dk*<sub>par</sub> ))
  - *c*<sub>i</sub> = *I*<sub>R</sub>

#### Diversifier derivation


The 88-bit diversifiers for a extended key are derived from its diversifier key *dk*. To prevent the
diversifier leaking how many diversified addresses have already been generated for an account, we make the
sequence of diversifiers pseudorandom and uncorrelated to that of any other account. In order to reach the
maximum possible diversifier range without running into repetitions due to the birthday bound, we use
FF1-AES256 as a Pseudo-Random Permutation as follows:

- Let *j* be the index of the desired diversifier, in the range 0 .. 2<sup>88</sup> -1.
- *d*<sub>j</sub> = FF1-AES256.Encrypt(*dk*, "", I2LEBSP<sub>88</sub> (*j*)).

A valid diversifier *d*<sub>j</sub> is one for which DiversifyHash(*d*<sub>j</sub>) ≠ ⊥.
For a given *dk*, approximately half of the possible values of *j* yield valid diversifiers.

The default diversifier for an extended key is defined to be *d*<sub>j</sub> , where *j* is the
least nonnegative integer yielding a valid diversifier.


### Fingerprints and Tags


#### Full Viewing Key Fingerprints and Tags


A full viewing key fingerprint with raw encoding *FVK*  is given by:

    BLAKE2b-256("TronFVFP", FVK)

It MAY be used to uniquely identify a particular full viewing key.

A "full viewing key tag" is the first 4 bytes of the corresponding full viewing key
fingerprint. It is intended for optimizing performance of key lookups, and MUST NOT be assumed to
uniquely identify a particular key.


### Key Encodings

The following encodings are analogous to the ``xprv`` and ``xpub`` encodings defined
in BIP 32 for transparent keys and addresses. Each key type has a raw representation
and a [Bech32](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki) encoding.


#### Extended Spending Keys

An extended spending key (*ask*, *nsk*, *ovk*, *dk*, *c*), at some *path*,
with parent full viewing key tag *parent_fvk_tag* and child number *i*, is
represented as a byte sequence:

  I2LEOSP<sub>8</sub> (*depth*) || *parent_fvk_tag* || I2LEOSP<sub>32</sub> (*i*) || *c* || EncodeExtSKParts(*ask*, *nsk*, *ovk*, *dk*)

For the master extended spending key, *depth* is 0, *parent_fvk_tag* is 4 zero bytes,
and *i* is 0.

When encoded as Bech32, the Human-Readable Part is ``secret-extended-key-main``
for the production network, or ``secret-extended-key-test`` for the test network.

#### Extended full viewing keys

A extended full viewing key (*ak*, *nk*, *ovk*, *dk*, *c*), at depth *depth*,
with parent full viewing key tag *parent_fvk_tag* and child number *i*, is
represented as a byte sequence:

   I2LEOSP<sub>8</sub> (*depth*) || *parent_fvk_tag* || I2LEOSP<sub>32</sub> (*i*) || *c* || EncodeExtFVKParts(*ak*, *nk*, *ovk*, *dk*)

For the master extended full viewing key, *depth* is 0, *parent_fvk_tag* is 4 zero bytes,
and *i* is 0.

When encoded as Bech32, the Human-Readable Part is ``txviews`` for the production
network, or ``txviewtest`` for the test network.


## Rationale

Based on [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) and [ZIP32](https://github.com/zcash/zips/blob/master/zip-0032.rst),  We provide a standard mechanism for both transparent and shielded hierarchical deterministic wallets for Tron.


## Implementation
None

## Reference
* https://pypi.org/project/bip32utils/
* https://github.com/NovaCrypto/BIP44
* https://github.com/zcash/zips/blob/master/zip-0032.rst
* https://github.com/zcash-hackworks/zip32
* https://github.com/zcash/librustzcash/pull/29





